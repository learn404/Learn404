---
title: Les fonctions synchrones et asynchrones en JavaScript
slug: les-fonctions-synchrones-et-asynchrones-en-javascript
---


Nous allons d√©couvrir ensemble ce qu'est la programmation asynchrone et pourquoi elle est n√©cessaire.

D√©j√†, la programmation asynchrone est une technique qui permet √† un programme de d√©marrer une t√¢che potentiellement longue et, au lieu d'attendre la fin de cette t√¢che, de continuer √† r√©agir aux autres √©v√©nements pendant son ex√©cution. Une fois la t√¢che termin√©e, le programme re√ßoit le r√©sultat.


![Conversion asynchrone/ synchrone](/img/lesson-les-fonctions-synchrones-et-asynchrones-en-javascript/conversion-asynchrone-synchrone.webp)



> üí° **Note:** Pensez √† une application web comme un restaurant. Pendant que vous attendez votre plat principal, vous pouvez discuter, regarder autour de vous, ou boire un verre. Vous n'√™tes pas bloqu√© en attendant que le plat soit pr√™t. C'est le m√™me principe pour la programmation asynchrone.

Une des fonctions fournies par les navigateurs, et qui peut prendre un certain temps, est l'envoi de requ√™tes asynchrones. Nous aborderons ce sujet dans le cours d'introduction aux API.

Commen√ßons par aborder les probl√®mes li√©s aux fonctions synchrones dont l'ex√©cution est longue, pour montrer pourquoi la programmation asynchrone est n√©cessaire.

## Programmation synchrone

```javascript
const nom = "Miriam";
const salutation = `Bonjour, je m'appelle ${nom} !`;
console.log(salutation);
// "Bonjour, je m'appelle Miriam !"
```

> üßë‚Äçüíª **Analyse du code:**
> 1. On d√©clare une variable intitul√©e `nom`, qui contient une cha√Æne de caract√®res.
> 2. On d√©clare une autre variable intitul√©e `salutation` qui utilise `nom`.
> 3. Et puis on affiche la salutation.

Il faut bien se rappeler que le navigateur ex√©cute un programme ligne par ligne, selon l'ordre dans lequel elles ont √©t√© √©crites.

Ce caract√®re s√©quentiel fait que nous avons un **programme synchrone**. M√™me si on appelle une fonction s√©par√©e, le programme reste synchrone :

```javascript
function creerSalutation(nom) {
  return `Bonjour, je m'appelle ${nom} !`;
}

const nom = "Miriam";
const salutation = creerSalutation(nom);
console.log(salutation);
// "Bonjour, je m'appelle Miriam !"
```

Ici, `creerSalutation()` est une **fonction synchrone**, car l'instruction qui l'appelle doit attendre que la fonction ait renvoy√© sa valeur de retour avant de pouvoir finir.

### Une fonction synchrone longue

Et si la fonction synchrone mettait beaucoup de temps √† s'ex√©cuter ?

Lorsqu'une personne clique sur le bouton ¬´ G√©n√©rer des nombres premiers ¬ª dans l'exemple qui suit, le programme g√©n√®re plusieurs grands nombres premiers en utilisant un algorithme tr√®s inefficace. On peut contr√¥ler la quantit√© de nombres premiers √† g√©n√©rer, ce qui aura un impact sur la dur√©e de l'op√©ration.

```html
<label for="quota">Quantit√© de nombres premiers :</label>
<input type="text" id="quota" name="quota" value="1000000" />

<button id="generer">G√©n√©rer des nombres premiers</button>
<button id="recharger">Recharger</button>

<div id="output"></div>
```

```javascript
function genererNbPremiers(quota) {
  function estPremier(n) {
    for (let c = 2; c <= Math.sqrt(n); ++c) {
      if (n % c === 0) {
        return false;
      }
    }
    return true;
  }

  const nbPremiers = [];
  const maximum = 1000000;

  while (nbPremiers.length < quota) {
    const candidat = Math.floor(Math.random() * (maximum + 1));
    if (estPremier(candidat)) {
      nbPremiers.push(candidat);
    }
  }

  return nbPremiers;
}

document.querySelector("#generer").addEventListener("click", () => {
  const quota = document.querySelector("#quota").value;
  const nbPremiers = genererNbPremiers(quota);
  document.querySelector("#output").textContent =
    `G√©n√©ration de ${quota} nombres premiers termin√©e !`;
});

document.querySelector("#recharger").addEventListener("click", () => {
  document.location.reload();
});
```

> üßë‚Äçüíª **Analyse du code :**
> 1. La fonction `genererNbPremiers` g√©n√®re des nombres premiers jusqu'√† atteindre le quota sp√©cifi√©.
> 2. Lorsque le bouton ¬´ G√©n√©rer des nombres premiers ¬ª est cliqu√©, la fonction est appel√©e, et le r√©sultat est affich√© dans l'√©l√©ment `#output`.
> 3. Le bouton ¬´ Recharger ¬ª permet de recharger la page pour r√©initialiser l'application.


---

SUPPRESSION APRES TOURNAGE

Essayez de cliquer sur le bouton ¬´ G√©n√©rer des nombres premiers ¬ª. Selon les performances de votre ordinateur, vous devrez probablement attendre quelques secondes avant de voir appara√Ætre le message sur l'op√©ration termin√©e.

---
Lorsqu'un programme synchrone ex√©cute une t√¢che longue comme dans l'exemple pr√©c√©dent, l'interface utilisateur peut devenir non r√©active, ce qui signifie que l'utilisateur ne peut pas interagir avec l'application tant que la t√¢che n'est pas termin√©e. Cela peut √™tre tr√®s frustrant pour les utilisateurs. C'est ici que la programmation asynchrone entre en jeu.

## Programmation asynchrone

La programmation asynchrone permet √† un programme de continuer √† fonctionner normalement tout en attendant la fin de l'ex√©cution d'une t√¢che longue. Cela est particuli√®rement utile dans des environnements comme le navigateur o√π l'interactivit√© est cruciale.

En JavaScript, cela peut √™tre accompli de plusieurs fa√ßons, y compris les **callbacks**, les **promesses** et les **fonctions async/await**.

---
SUPPRESSION APRES TOURNAGE

Regardons comment nous pouvons am√©liorer notre exemple de g√©n√©ration de nombres premiers en utilisant des techniques de programmation asynchrone.

---

### Utilisation de setTimeout pour une fonction asynchrone

Une des fa√ßons les plus simples de rendre notre fonction de g√©n√©ration de nombres premiers asynchrone est d'utiliser `setTimeout`. Cette m√©thode permet de fragmenter l'ex√©cution de t√¢ches longues en morceaux plus petits, ce qui donne au navigateur l'opportunit√© de g√©rer d'autres t√¢ches pendant les pauses, am√©liorant ainsi la r√©activit√© de l'interface utilisateur.

Voici comment nous pouvons adapter notre exemple de g√©n√©ration de nombres premiers en utilisant `setTimeout` :

```javascript
function genererNbPremiersAsync(quota, callback) {
  function estPremier(n) {
    for (let c = 2; c <= Math.sqrt(n); ++c) {
      if (n % c === 0) {
        return false;
      }
    }
    return true;
  }

  const nbPremiers = [];
  const maximum = 1000000;

  function trouverNbPremiers() {
    while (nbPremiers.length < quota) {
      const candidat = Math.floor(Math.random() * (maximum + 1));
      if (estPremier(candidat)) {
        nbPremiers.push(candidat);
      }

      // Pause pour permettre au navigateur de respirer
      if (nbPremiers.length % 1000 === 0) {
        setTimeout(trouverNbPremiers, 0);
        return;
      }
    }
    callback(nbPremiers);
  }

  trouverNbPremiers();
}

document.querySelector("#generer").addEventListener("click", () => {
  const quota = document.querySelector("#quota").value;
  genererNbPremiersAsync(quota, (nbPremiers) => {
    document.querySelector("#output").textContent =
      `G√©n√©ration de ${quota} nombres premiers termin√©e !`;
  });
});

document.querySelector("#recharger").addEventListener("click", () => {
  document.location.reload();
});
```

> üßë‚Äçüíª **Analyse du code :**
> 1. La fonction `genererNbPremiersAsync` prend deux arguments : le `quota`, qui repr√©sente le nombre de nombres premiers √† g√©n√©rer, et un `callback` qui sera appel√© lorsque la g√©n√©ration est termin√©e.
> 2. √Ä l'int√©rieur de cette fonction, nous d√©finissons `estPremier`, une fonction utilitaire qui v√©rifie si un nombre est premier.
> 3. Nous utilisons une boucle `while` pour g√©n√©rer des nombres premiers jusqu'√† atteindre le quota souhait√©.
> 4. Pour √©viter de bloquer le navigateur, nous ins√©rons une pause avec `setTimeout` apr√®s chaque groupe de 1000 nombres premiers v√©rifi√©s. Cette pause permet au navigateur de rester r√©actif en traitant d'autres √©v√©nements pendant ce temps.
> 5. Une fois que le quota est atteint, le `callback` est appel√© avec la liste des nombres premiers g√©n√©r√©s.
> 6. Lorsqu'un utilisateur clique sur le bouton ¬´ G√©n√©rer des nombres premiers ¬ª, nous invoquons `genererNbPremiersAsync` et mettons √† jour l'interface utilisateur avec le r√©sultat une fois la g√©n√©ration termin√©e.
> 7. Le bouton ¬´ Recharger ¬ª permet de recharger la page pour r√©initialiser l'application.

> üîÑ **Astuce:** Utilisez `setTimeout` pour cr√©er des pauses r√©guli√®res dans votre fonction afin de permettre au navigateur de rester r√©actif. Cela am√©liore l'exp√©rience utilisateur en √©vitant les blocages de l'interface.

### Utilisation de Promises

Les **promesses** (Promises) en JavaScript sont un outil puissant pour g√©rer des op√©rations asynchrones de mani√®re plus propre et lisible que les callbacks traditionnels. Une promesse repr√©sente une valeur qui peut √™tre disponible maintenant, dans le futur, ou jamais. Cela permet d'√©crire du code asynchrone en √©vitant les ¬´ pyramides de l'enfer ¬ª caus√©es par des callbacks imbriqu√©s.


Voici comment nous pouvons utiliser des promesses pour am√©liorer notre exemple de g√©n√©ration de nombres premiers :

```javascript
function genererNbPremiersAsync(quota) {
  return new Promise((resolve) => {
    function estPremier(n) {
      for (let c = 2; c <= Math.sqrt(n); ++c) {
        if (n % c === 0) {
          return false;
        }
      }
      return true;
    }

    const nbPremiers = [];
    const maximum = 1000000;

    function trouverNbPremiers() {
      while (nbPremiers.length < quota) {
        const candidat = Math.floor(Math.random() * (maximum + 1));
        if (estPremier(candidat)) {
          nbPremiers.push(candidat);
        }

        if (nbPremiers.length % 1000 === 0) {
          // Pause pour permettre au navigateur de continuer √† r√©agir aux autres √©v√©nements
          setTimeout(trouverNbPremiers, 0);
          return;
        }
      }
      // Une fois que la t√¢che est termin√©e, la promesse est r√©solue
      resolve(nbPremiers);
    }

    trouverNbPremiers();
  });
}

document.querySelector("#generer").addEventListener("click", () => {
  const quota = document.querySelector("#quota").value;
  genererNbPremiersAsync(quota).then((nbPremiers) => {
    document.querySelector("#output").textContent =
      `G√©n√©ration de ${quota} nombres premiers termin√©e !`;
  });
});

document.querySelector("#recharger").addEventListener("click", () => {
  document.location.reload();
});
```

> üßë‚Äçüíª **Analyse du code :**
> 1. La fonction `genererNbPremiersAsync` retourne une promesse qui encapsule la logique de g√©n√©ration des nombres premiers.
> 2. √Ä l'int√©rieur de cette fonction, nous d√©finissons `estPremier`, qui v√©rifie si un nombre est premier.
> 3. Nous utilisons `setTimeout` pour ins√©rer des pauses dans la boucle de g√©n√©ration, permettant ainsi au navigateur de rester r√©actif.
> 4. Une fois que la g√©n√©ration est termin√©e, nous appelons `resolve(nbPremiers)` pour signaler que la promesse est compl√©t√©e avec succ√®s.
> 5. Lorsqu'un utilisateur clique sur le bouton ¬´ G√©n√©rer des nombres premiers ¬ª, nous invoquons `genererNbPremiersAsync`, et utilisons `.then` pour traiter le r√©sultat lorsque la promesse est r√©solue.

En utilisant des promesses, nous rendons le flux de notre programme plus clair et maintenons une structure de code lisible et modulaire, facilitant ainsi la gestion des op√©rations asynchrones.

### Utilisation de async/await

Les **fonctions async/await** sont une am√©lioration par rapport aux promesses qui permet d'√©crire du code asynchrone de mani√®re encore plus lisible et proche du style synchrone. Cette syntaxe permet de g√©rer les op√©rations asynchrones avec un code qui est plus facile √† comprendre et √† maintenir.

Voici comment nous pouvons utiliser `async/await` pour am√©liorer notre exemple de g√©n√©ration de nombres premiers :

```javascript
async function genererNbPremiersAsync(quota) {
  function estPremier(n) {
    for (let c = 2; c <= Math.sqrt(n); ++c) {
      if (n % c === 0) {
        return false;
      }
    }
    return true;
  }

  const nbPremiers = [];
  const maximum = 1000000;

  while (nbPremiers.length < quota) {
    const candidat = Math.floor(Math.random() * (maximum + 1));
    if (estPremier(candidat)) {
      nbPremiers.push(candidat);
    }

    if (nbPremiers.length % 1000 === 0) {
      // Pause pour permettre au navigateur de continuer √† r√©agir aux autres √©v√©nements
      await new Promise(resolve => setTimeout(resolve, 0));
    }
  }

  return nbPremiers;
}

document.querySelector("#generer").addEventListener("click", async () => {
  const quota = document.querySelector("#quota").value;
  const nbPremiers = await genererNbPremiersAsync(quota);
  document.querySelector("#output").textContent =
    `G√©n√©ration de ${quota} nombres premiers termin√©e !`;
});

document.querySelector("#recharger").addEventListener("click", () => {
  document.location.reload();
});
```

> üßë‚Äçüíª **Analyse du code :**
> 1. La fonction `genererNbPremiersAsync` est d√©clar√©e avec le mot-cl√© `async`, ce qui lui permet d'utiliser `await` pour g√©rer des op√©rations asynchrones.
> 2. √Ä l'int√©rieur de cette fonction, nous d√©finissons `estPremier`, qui v√©rifie si un nombre est premier.
> 3. Nous utilisons `await new Promise(resolve => setTimeout(resolve, 0))` pour ins√©rer des pauses dans la boucle de g√©n√©ration, permettant ainsi au navigateur de rester r√©actif sans bloquer l'interface utilisateur.
> 4. La boucle continue jusqu'√† ce que la quantit√© souhait√©e de nombres premiers soit g√©n√©r√©e.
> 5. Lorsque la g√©n√©ration est termin√©e, la fonction retourne la liste des nombres premiers g√©n√©r√©s.
> 6. Lorsqu'un utilisateur clique sur le bouton ¬´ G√©n√©rer des nombres premiers ¬ª, nous invoquons `genererNbPremiersAsync` et utilisons `await` pour attendre que la g√©n√©ration soit termin√©e avant de mettre √† jour l'interface utilisateur.

---
SUPPRESSION APRES TOURNAGE

En utilisant `async/await`, nous obtenons un code asynchrone qui est aussi simple et lisible que du code synchrone, tout en b√©n√©ficiant des avantages de l'asynchronicit√©. Cette approche est particuli√®rement utile pour √©crire des applications interactives et r√©actives, car elle permet de g√©rer des t√¢ches longues sans bloquer l'interface utilisateur, offrant ainsi une meilleure exp√©rience utilisateur.

---

> üîÑ **Conseil pratique:** Utilisez `async/await` pour simplifier la gestion des op√©rations asynchrones. Cela rend le code plus lisible et maintenable, tout en pr√©servant les avantages de la programmation asynchrone.


Apr√®s avoir vu une notion qui peut paraitre etre complexe mais qui est utile au quotidien pour les d√©veloppeur.
